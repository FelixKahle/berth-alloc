// scheduling/propagate.rs
use crate::{
    core::decisionvar::IntervalVar,
    state::{
        chain_set::view::{ChainRef, ChainSetView},
        model::SolverModel,
        index::{RequestIndex, BerthIndex},
    },
};
use berth_alloc_core::prelude::{TimePoint, TimeInterval, TimeDelta};
use num_traits::{CheckedAdd, CheckedSub};

#[derive(Debug)]
pub struct BoundsTightener<'m, 'p, T: Copy + Ord> {
    model: &'m SolverModel<'p, T>,
}

impl<'m, 'p, T> BoundsTightener<'m, 'p, T>
where
    T: Copy + Ord + CheckedAdd + CheckedSub,
{
    #[inline]
    pub fn new(model: &'m SolverModel<'p, T>) -> Self {
        Self { model }
    }

    /// Tighten LB/UB for an entire chain (forward + backward).
    #[inline]
    pub fn tighten_chain<C: ChainSetView>(
        &self,
        chain: ChainRef<'_, C>,
        ivars: &mut [IntervalVar<T>],
    ) {
        let start = chain.start();
        let end_excl = None;
        self.tighten_forward_slice(chain, ivars, start, end_excl);
        self.tighten_backward_slice(chain, ivars, start, end_excl);
    }

    /// Tighten LB/UB on [start_node, end_node_excl)
    #[inline]
    pub fn tighten_slice<C: ChainSetView>(
        &self,
        chain: ChainRef<'_, C>,
        ivars: &mut [IntervalVar<T>],
        start_node: crate::state::chain_set::index::NodeIndex,
        end_node_excl: Option<crate::state::chain_set::index::NodeIndex>,
    ) {
        self.tighten_forward_slice(chain, ivars, start_node, end_node_excl);
        self.tighten_backward_slice(chain, ivars, start_node, end_node_excl);
    }

    /// Forward pass: raises lower_bound_start_time via precedence + calendar + windows.
    fn tighten_forward_slice<C: ChainSetView>(
        &self,
        chain: ChainRef<'_, C>,
        ivars: &mut [IntervalVar<T>],
        start_node: crate::state::chain_set::index::NodeIndex,
        end_node_excl: Option<crate::state::chain_set::index::NodeIndex>,
    ) {
        let berth = BerthIndex(chain.index().get());
        let cal = match self.model.berth_calendar_for_berth(berth) {
            Some(c) => c,
            None => return, // nothing to do; leave bounds as-is
        };
        let free = cal.free_intervals();

        // earliest = max(prev end, first calendar start) at the slice entry
        let mut earliest: TimePoint<T> = if let Some(prev) = chain.prev(start_node) {
            let r_prev = RequestIndex(prev.get());
            ivars[r_prev.get()]
                .end_from_start()
                .unwrap_or_else(|| free.first().map(|iv| iv.start()).unwrap_or_else(|| {
                    // degenerate: no free intervals
                    ivars[r_prev.get()].lower_bound_start_time
                }))
        } else {
            free.first().map(|iv| iv.start())
                .unwrap_or_else(|| ivars[RequestIndex(start_node.get()).get()].lower_bound_start_time)
        };

        // Monotone scan of calendar segments
        let mut seg_idx = advance_to_segment(free, 0, earliest);

        // Walk forward and raise LB
        let mut n = Some(start_node);
        while let Some(node) = n {
            if let Some(end) = end_node_excl {
                if node == end { break; }
            }
            let r = RequestIndex(node.get());
            let v = &mut ivars[r.get()];
            // new LB = max(current LB, earliest, window.start)
            let mut lb = max3(v.lower_bound_start_time, earliest, v.time_interval.start());

            // also ensure we can still finish by UB: UB_end = min(window.end, v.upper_bound_end_time)
            let cap_end = min2(v.time_interval.end(), v.upper_bound_end_time);
            if let Some(latest_start) = cap_end.checked_sub(v.processing_time) {
                if lb > latest_start {
                    // infeasible; raise to latest_start to signal contradiction (scheduler will fail)
                    lb = latest_start;
                }
            }
            v.lower_bound_start_time = lb;

            // Compute earliest feasible end given calendar ∩ window and lb
            if let Some((s, e)) = earliest_fit_in_calendar_with_cap(
                free, &mut seg_idx, v.time_interval, lb, v.processing_time, cap_end,
            ) {
                earliest = e;                 // precedence for the next
                seg_idx = advance_to_segment(free, seg_idx, earliest);
            } else {
                // No fit inside bounds; still set earliest to lb + pt to keep precedence monotone
                if let Some(e) = lb.checked_add(v.processing_time) {
                    earliest = e;
                }
            }

            n = chain.next(node);
        }
    }

    /// Backward pass: lowers upper_bound_end_time via precedence (right→left) + calendar + windows.
    fn tighten_backward_slice<C: ChainSetView>(
        &self,
        chain: ChainRef<'_, C>,
        ivars: &mut [IntervalVar<T>],
        start_node: crate::state::chain_set::index::NodeIndex,
        end_node_excl: Option<crate::state::chain_set::index::NodeIndex>,
    ) {
        let berth = BerthIndex(chain.index().get());
        let cal = match self.model.berth_calendar_for_berth(berth) {
            Some(c) => c,
            None => return,
        };
        let free = cal.free_intervals();

        // Find right boundary node (exclusive) and the last node we actually tighten.
        // We’ll walk right→left by chasing prev().
        let right_excl = end_node_excl.unwrap_or_else(|| chain.end());
        // identify the last included node in the slice:
        let mut last_incl = chain.prev(right_excl);

        // Start from the rightmost feasible calendar end (or UB) as "latest_end"
        // We’ll just use the last_incl’s current UB as seed;
        // if None (no node), nothing to do.
        let mut latest_end: Option<TimePoint<T>> = None;

        // Simple approach: compute a conservative cap from calendar tail if available
        if let Some(&tail_iv) = free.last() {
            latest_end = Some(tail_iv.end());
        }

        // Traverse nodes right→left
        while let Some(n) = last_incl {
            let r = RequestIndex(n.get());
            let v = &mut ivars[r.get()];

            let window_cap = v.time_interval.end();
            let ub_cap    = v.upper_bound_end_time;
            let mut cap_end = min2(window_cap, ub_cap);

            if let Some(le) = latest_end {
                // Enforce that this node must finish by the current right-going “latest_end”
                if le < cap_end { cap_end = le; }
            }

            // Try to also respect calendar by snapping to the leftmost end <= cap_end
            cap_end = cap_end.min(find_calendar_cap_end(free, cap_end));

            v.upper_bound_end_time = cap_end;

            // Update “latest_end” for the previous node: it must end before
            // the start of this one (cap_end - PT), ignoring exact calendar fit here
            latest_end = cap_end.checked_sub(v.processing_time);

            last_incl = chain.prev(n);
            if last_incl.is_some() && last_incl == chain.prev(start_node) {
                // We reached before the left boundary
                break;
            }
        }
    }
}

/* ---------- tiny helpers (private to module) ---------- */

fn advance_to_segment<T>(free: &[TimeInterval<T>], mut i: usize, t: TimePoint<T>) -> usize
where
    T: Copy + Ord,
{
    while i < free.len() && free[i].end() <= t { i += 1; }
    i
}

fn earliest_fit_in_calendar_with_cap<T: Copy + Ord + CheckedAdd>(
    free: &[TimeInterval<T>],
    seg_idx: &mut usize,
    window: TimeInterval<T>,
    lb: TimePoint<T>,
    pt: TimeDelta<T>,
    cap_end: TimePoint<T>,
) -> Option<(TimePoint<T>, TimePoint<T>)> {
    let mut i = advance_to_segment(free, *seg_idx, lb);
    while i < free.len() {
        if let Some(slot) = free[i].intersection(&window) {
            if !slot.is_empty() {
                let slot_end_cap = min2(slot.end(), cap_end);
                if slot.start() < slot_end_cap {
                    let s = max2(slot.start(), lb);
                    if s < slot_end_cap {
                        if let Some(e) = s.checked_add(pt) {
                            if e <= slot_end_cap {
                                *seg_idx = i;
                                return Some((s, e));
                            }
                        }
                    }
                }
            }
        }
        i += 1;
    }
    None
}

fn find_calendar_cap_end<T: Copy + Ord>(free: &[TimeInterval<T>], cap_end: TimePoint<T>) -> TimePoint<T> {
    // Returns min(cap_end, first slot.end() that is >= cap_end), else cap_end
    // (Cheap & conservative; you can make this smarter if you want.)
    for iv in free.iter().rev() {
        if iv.start() <= cap_end && cap_end <= iv.end() {
            return cap_end;
        }
        if iv.end() < cap_end {
            return iv.end(); // next allowed end to the left
        }
    }
    cap_end
}

#[inline] fn max2<T: Ord>(a: T, b: T) -> T { if a >= b { a } else { b } }
#[inline] fn min2<T: Ord>(a: T, b: T) -> T { if a <= b { a } else { b } }
#[inline] fn max3<T: Ord + Copy>(a: T, b: T, c: T) -> T { max2(max2(a,b), c) }
